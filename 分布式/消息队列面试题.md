# 消息队列面试题

消息中间件是分布式系统重要组件，常用消息队列有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ

### 1、消息队列的主要作用

也可以说是消息队列的应用场景，有哪些好处？优点

* 异步
* 解耦
* 削峰填谷

**缺点：**

* 降低系统的可用性：系统引入的外部依赖越多，越容易挂掉；
* 系统复杂度提高：使用 MQ 后可能需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题；
* 一致性问题：A 系统处理完了直接返回成功了，但问题是：要是 B、C、D 三个系统那里，B 和 D 两个系统写库成功了，结果 C 系统写库失败了，就造成数据不一致了。

### 2、消息模型有哪些？

在JMS标准中，有两种消息模型P2P（Point to Point）,Publish/Subscribe(Pub/Sub)。

ActiveMQ有两种通信方式，点到点形式和发布订阅模式。
如果是点到点模式的话，如果消息发送不成功，此消息默认会保存到ActiveMQ服务端直到有消费者将其消费，所以此消息是不会丢失的。
如果是发布订阅模式的通信方式，默认情况只通知一次，如果接受不到此消息就没有了，这种场景使用于对消息发送率要求不高的情况，如果要求消息必须送达不可以丢失的话，需要配置持久订阅。每个订阅端定义一个id，在订阅是向ActiveMQ注册，发布消息和接受消息时需要配置发送模式为持久化，此时如果客户端接受不到消息，消息会持久化到服务端，直到客户端正常接收后为止。

---

### 3、如何保证消息队列的高可用

**类似于：如何防止消息丢失？**

1. **以activemq为例**

* 事务（偏生产者）
* 签收(偏消费者)
* 持久化（代码层面、配置层面（kahaDB、jdbc、amq(已淘汰)、leveldb（未来趋势）））
* zookeeper+activemq集群

### 4、如何保证消息不被重复消费？或者说，如何保证消息消费的幂等性？

**幂等性：**无论你重复请求多少次，得到的结果都是一样的。例如：一条数据重复出现两次，数据库里就只有一条数据，这就保证了系统的幂等性

比如你拿个数据要写库，你先根据主键查一下，如果这数据都有了，你就别插入了，update 一下好吧。

比如你是写 Redis，那没问题了，反正每次都是 set，天然幂等性。

比如你不是上面两个场景，那做的稍微复杂一点，你需要让生产者发送每条数据的时候，里面加一个全局唯一的 id，类似订单 id 之类的东西，然后你这里消费到了之后，先根据这个 id 去比如 Redis 里查一下，之前消费过吗？如果没有消费过，你就处理，然后这个 id 写 Redis。如果消费过了，那你就别处理了，保证别重复处理相同的消息即可。

比如基于数据库的唯一键来保证重复数据不会重复插入多条。因为有唯一键约束了，重复数据插入只会报错，不会导致数据库中出现脏数据。

### 5、哪些情况会引起消息重发?死信队列？

设计到：消息重发时间间隔、重发次数、有毒消息（poison ack）、死信队列

**以activemq为例**

https://blog.csdn.net/qq_20597727/article/details/81416812

### 6、activemq的持久化订阅和非持久化订阅？

https://my.oschina.net/thinwonton/blog/888654

### 7、如何保证消息的顺序？

对于activeMQ，可以通过exclusive方式让一个queue始终被一个consumer消费；或者messageGroup方式；

### 8、消息队列积压怎么办

不建议在生产环境使用数据过期策略，一是数据是否丢失无法控制，二是一旦积压就很有可能丢失；建议数据的处理都有代码来控制；

当出现消息积压时，做法就是临时扩大consumer个数，让消息快速消费，一般都是通过业务逻辑的手段来完成：如下：

【rabbitmq解决积压范例】

修复consumer代码故障，确保consumer逻辑正确可以消费；

停止consumer，开启10倍20倍的queue个数；

创建一个临时的consumer程序，消费积压的queue，并把消息写入到扩建的10倍queue中；
再开启10倍20倍的consumer对新的扩充后队列进行消费；
 这种做法相当于通过物理资源扩充了10倍来快速消费；

当消费完成后，需要恢复原有架构，开启原来的consumer进行正常消费；

### 9、activemq的异步投递、定时投递、延迟投递

续问：异步发送如何确认消息发送成功？

答：回调函数

https://www.jianshu.com/p/58e9deae6c4b